--PACKAGES/PROC'S/Triggers/Indexes/collection/TEMPORARY TABLEs

---Logically grouping of subprograms,security,Better performance
--performance
		--entire package is loaded into memory when the package is first referenced
--features that can be implemented only within 
	--Overloading of subprograms
	--Global Variables and constants--common cursor,common exception,commom collection
	
--initialisation block/ONE TIME ONLY PROCEUDRE
CREATE OR REPLACE PACKAGE MY_PACK1 AS
LV_NUM_EMP NUMBER;
PROCEDURE PRINT;
END MY_PACK1;
/

CREATE PACKAGE BODY MY_PACK1 AS

PROCEDURE PRINT 
AS
BEGIN
DBMS("NO.OF EMP = "||LV_NUM_EMP);
END PRINT;

BEGIN
SELECT COUNT (*) INTO LV_NUM_EMP
FROM EMP;

END MY_PACK1;
/

-----private procedure(ONLY WITHIN THE BODY OF PKG)/FUNCTION

CREATE PACKAGE test__pkg1 AS
PROCEDURE p1_proc;
procedure p2_proc;
end;
/

CREATE package body test__pkg1 AS
	PROCEDURE private_proc AS
	BEGIN
	end;
	PROCEDURE p1_proc AS
	BEGIN
	private_proc;
	end;
	PROCEDURE p2_proc AS
	BEGIN
	private_proc;
	end;
end test__pkg1;
/

-------LOCAL PROCEDURE (DEFINING IN ANOTHER BLOCK OR NESTED PROC)

DECLARE
	PROCEDURE LOCAL_PROC AS
	BEGIN
	DBMS();
	END;
BEGIN
	LOCAL_PROC;
END;
/



----CONSTRAINTS
 --CONSTRAINT VALIDATE THE DATA BEFORE GETTING LOADED INTO TABLE
 

ALTER TABLE   EMP ADD CONSTANT EMPNO_PK PRIMARY KEY (EMPNO) DEFERRABLE NOVALIDATE;

---CREATING PK CONSTANT AUTOMATICALLY CREATES THE UNIQUE INDEX PROVIDED IF THERE IS NO INDEX ON THAT COLUMN ALREADY
--

ALTER TABLE TAB_NAME DROP CONSTRAINT EMPNO_PK;
--DROPPING A TBABLE--ALSO DROPS THE INDEX,CONSTRAINTS AND TRIGGER
--DEFERRABLE NOVALIDATE PRIMARY KEY ALSO CREATES A NON UNIQUE INDEX 



CREATE TABLE T
(C NUMBER NOT NULL,
CONSTRAINT UK UNIQUE(C),
CONSTANT PK PRIMARY (C)
)
/


ALTER TABLE SALARY_HISTORY ADD CONSTRAINT SAL_FK FOREIGN KEY (EMP_ID) REFERENCES EMP(E_ID) ON DELETE CASCADE/SET NULL;

ALTER TABLE DEPT DROP COLUMN DEP_ID CASCADE CONSTRAINT;

RENAME/


CREATE TABLE CONT_TB
(CONT_ID NUMBER PRIMARY KEY,
CONT VARCHAR(20));

ALTER TABLE CONT_TB RENAME CONSTRAINT SYS_C0030229 TO CONT_ID_PK;

CREATE TABLE COUNTRY_TB
(C_ID NUMBER,
CONT_ID NUMBER,
CONSTRAINT COUNTRY_FK FOREIGN KEY (CONT_ID) REFERENCES CONT_TB(CONT_ID)
);



SELECT * FROM USER_CONSTRAINTS;

ALTER TABLE CONT_TB ADD  CONT_ID NUMBER PRIMARY KEY;

INSERT INTO CONT_TB VALUES ('ASIA',1);
INSERT INTO CONT_TB VALUES ('EUROPE',2);

ALTER TABLE COUNTRY_TB ADD CONSTRAINT COUNTRY_PK PRIMARY KEY (CONT_ID) DEFERRABLE NOVALIDATE;

ALTER TABLE COUNTRY_TB DROP CONSTRAINT COUNTRY_FK;

INSERT INTO COUNTRY_TB VALUES (20,2);

SELECT * FROM COUNTRY_TB;
--------------------
TRUNCATE  TABLE EMP_GLOBAL;
CREATE GLOBAL TEMPORARY TABLE EMP_GLOBAL_REF
ON COMMIT PRESERVE ROWS AS 
SELECT * FROM EMP;

SELECT  /*insert*/ * FROM EMP WHERE ROWNUM=1;
WHERE SQL_TEXT LIKE '%EMP_GLOBAL%' OR SQL_FULLTEXT LIKE '%EMP_GLOBAL%';

Insert into EMP_GLOBAL (EMP_ID,EMP_NAME,SALARY,MANAGER_ID,EMP_AGE,DEP_ID,DEP_NAME,GENDER) values (3,'Ankit',14300,4,39,100,'Analytics','Female');


SELECT * FROM EMP_GLOBAL_REF;

---------FOR/FORALL

FOR 						FOR ALL
ITERATIVE 					NOT AN ITERATIVE STMT.DECLARATIVE STMT
STATEMENT 					
		
ANY NUMBER OF STMTS 		ONLY ONE DML ALLOWED
CAN BE WRITTEN	
							EFFECTIVELY TRANSFTERS THE DATA FROM COLLECTION TO TABLE
								REDUCES THE CONTEXT SWITCH..PERFOMANCE IMPROVEMENT


---------TABLE FUNCTION

CREATE TYPE T_NUM_LIST IS TABLE OF NUMBER;

SELECT * FROM TABLE(T_NUM_LIST(1,2,3,4,5));

---FUNC. TAHT RETURN COLLECTION 
---TABLE()


--PIPELINED FUNCTION-NOT NECESS.FULLY POPULATED.

---TABLE FUNCTION LOADS ALL THE VALUES INTO COLLECTION AND COLLE. RETURNED TO CALLER
--PIPELINED FUNC.--WHEN THE VALUE IS READY AND SENDBACK TO CALLER

CREATE FUNCITON E_NAME 
RETURN T_EMP_LIST PIPELINED 
AS
LV_EMP_lIST T_EMP_LIST;
BEGIN
FOR I IN (SELECT ENAME FROM EMP)
LOOP
LV_EMP_lIST.EXTEND;
LV_EMP_lIST(LV_EMP_lIST.LAST):=I.ENAME;
RETURN LV_EMP_lIST;
END LOOP;
----------

FOR I IN (SELECT ENAME FROM EMP)
LOOP
PIPE ROW (I.ENAME);
END LOOP;
RETURN;

END;
/

CREATE TYPE EMP_ROW AS
OBJECT (EMPNO NUMBER,ENAME VARCHAR(100),SAL NUMBER)
/

CREATE TYPE T_EMP_LIST IS TABLE OF EMP_ROW;
/


--------------INDEX
a smaller set of dara along with rowid
--fast access to roes

---------b tree,bit map index, FUNCTION based ,REVERSE key INDEX

--b tree (high cardinality)

--bit map-which has less distict data col
ROWID P F NOTAVA
1		
--function nased --
---B tree
		--ordered listof valuies divided into ranages in each index SEGMENT
		
--INDX USAGE, USING V$SQL AND V$SESSION USING SQLID--ACTUAL EXPLAIN PLAN
--INDEX MONITOR
--dba_object_usage v$object_usage
---------

----SCAN


NON UNIQUE INDEX() --WILL DO RANGE SCAN--RANGE SCAN_INSTANCES CHEMA--NON  UNIQUE SCAN AND ITS CHECK INDEX SEGMENT
UNIQUE INDEX -UNIQUE SCAN--

INDEX FULL SCAN--INDEX ON SAL COLUMN--NO NEED OF OPTIMIZER TO GO TO TABLE FOR ANY AGGREGATION-COMPUTING THE SUM FROMINDEX SEGMENT
--INDEX DATA WILL BE SMALLLER--NO TABLE ACCESS

-INDEX FULL SCAN (MIN/MAX)--SELECT MAX (SAL) FROM EMP;

INDEX FAST FULL SCAN-- 	SELECT empno,sal from emp; --2 diff.INDEX on 2 coln


--------REVERSE KEY INDEX--INDEX BLOCK CONTENTION


----------MUTATING TRIGGER

---A DML TSTMT THAT FIREST TRIGGER THAT READ /WRITES ON THE SAME TABLE.
--DML --TRIGEGER-READ /WRITE SAME TABLE 
--WHENEVER A ROWLEVEL TRIGGER TRIES TO MODIFY /SELECT THE DATA FROM THE TABLE THAT IS ALREADY UNDERGOING CHANGE

--ROWLEVEL TRIGGER ONLY
---STATEMENT LEVEL TRIGGER-->INIT. PACKAGED VARIABLE-->ROW LEVEL TRIGGER USES THE PACKAGED VARIABLE

PROC:
OPTIONALLY RETURN VALUE USING OUT/IN OUT PARAMETER
CANNOT BE CALLED FROM SQL STMT
USED TO IMPLEMENT LOGICAL DATA FLOW
CAN HAVE DML STMTS
RETURN TO OUT OF PROCEUDRE

FUNC:
ALWAYS RETURN A VALUE;
USED FOR COMPUTATIONAL PURPOSE
CAN HAVE DML-->CANT BE CALLED FROM SELECT
RETRUN TO REURN THE VALUE

FROM 12.1--WITH CALUSE 



--SCALAR DATA TYPES


----COMPOSITE 
	--RECORD
	--DIFF.DATATYPES CAN BE STORED
			--TYPE,%ROWTYPE
DECLARE
TYPE ADD_REC_TYPE IS RECORD (NAME VARCHAR(3),...PIN NUMBER);
LV_ADD_TYPE ADD_REC_TYPE;
BEGIN
LV_ADD_TYPE.NAME:=;
END;
/

DECLARE
TYPE EMP_REC_TYPE IS RECORD (ENAME EMP.ENAME%TYPE,
							 SAL EMP.SAL%TYPE);
LV_EMP_REC_TYPE 	EMP_REC_TYPE;
					
BEGIN
SELECT ENAME,SAL INTO LV_EMP_REC_TYPE
FROM EMP WHERE ENAME='';
END;
/

	--COLLECTION
--ONLY SAME DATA TYPE CAN BE STORED	
		--VARRAY, NESTED TABLE, ASSOC.ARRAY
		
----VARRAY
DECLARE
TYPE V_ARRAY_TYPE IS VARRAY(7) OF VARCHAR2(30);



---------------

CREATE OR REPLACE TYPE EMP_ROW AS
OBJECT (EMPID NUMBER,ENAME VARCHAR(100),SAL NUMBER)
/

CREATE OR REPLACE TYPE T_EMP_LIST IS TABLE OF  EMP_ROW;
/
CREATE OR REPLACE FUNCTION EMP_REF
RETURN T_EMP_LIST 
AS 
LV_EMP_LIST_1 T_EMP_LIST:=T_EMP_LIST();


TYPE T_ENAME IS TABLE OF VARCHAR2(100);
LV_T_ENAME1 T_ENAME;
TYPE EMP_LIST IS RECORD (ID NUMBER,NAME VARCHAR(30));
LV_EMP_LIST EMP_LIST;
BEGIN

FOR I IN (SELECT EMP_ID,EMP_NAME,SALARY FROM EMP)
LOOP
LV_EMP_LIST_1.EXTEND;
LV_EMP_LIST_1(LV_EMP_LIST_1.LAST):=EMP_ROW(I.EMP_ID, I.EMP_NAME, I.SALARY);
END LOOP;
RETURN LV_EMP_LIST_1;
--SELECT EMP_ID,EMP_NAME
--BULK COLLECT INTO LV_EMP_LIST
--FROM EMP;


END;
/

CREATE OR REPLACE FUNCTION EMP_REF_1
RETURN SYS_REFCURSOR 
AS 
LV_REF_CURSOR SYS_REFCURSOR;
BEGIN

OPEN LV_REF_CURSOR
FOR SELECT * FROM EMP;

RETURN LV_REF_CURSOR;

END;
/
SET SERVEROUTPUT ON
/
DECLARE
LV_REF SYS_REFCURSOR;
LV_EMP EMP%ROWTYPE;
BEGIN
LV_REF:=EMP_REF_1;
LOOP
FETCH LV_REF INTO LV_EMP;
DBMS_OUTPUT.PUT_LINE(LV_EMP.EMP_NAME);
EXIT WHEN LV_REF%NOTFOUND;
END LOOP;
CLOSE LV_REF;
END;
/
SELECT * FROM EMP_REF()
WHERE ROWNUM<=3;
/

SELECT * FROM EMP;
----------MUTATING TRIGGER
CREATE PACKAGE PKG1 AS
LV_MAX_SAL NUMBER;
END PKG1;
/
CREATE OR REPLACE TRIGGER TR_STMT_SAL
BEFORE UPDATE OF SALARY ON EMP
DECLARE
BEGIN

SELECT MAX(SALARY) INTO PKG1.LV_MAX_SAL
FROM EMP;
END;
/

CREATE OR REPLACE TRIGGER TR_SAL
BEFORE UPDATE OF SALARY ON EMP
FOR EACH ROW
DECLARE
BEGIN


IF :NEW.SALARY>PKG1.LV_MAX_SAL
THEN
RAISE_APPLICATION_ERROR (-20001,'TRIGGER FIRED- UPDATING VALUE EXCEEDING LIMIT');
ELSE 
DBMS_OUTPUT.PUT_LINE ('UPDATED SUCCESSFULY OLD VALUE = '||:OLD.SALARY||' NEW VALUE = '||:NEW.SALARY);
END IF ;
END;
/

SET SERVEROUTPUT ON;
UPDATE EMP
SET SALARY=1000000 WHERE EMP_ID=4;


---------TYPES OF BINDING
INBIND- TRANSFERRING COLLECTION DATA INTO A TABLE USING FORALL

DECLARE
TYPE T_NUM_LIST_TYPE IS TABLE OF NUMBER;
LV_NUM_LIST T_NUM_LIST_TYPE:=T_NUM_LIST_TYPE(1,2,3,4,5);
BEGIN
FORALL I IN LV_NUM_LIST.FIRST..LV_NUM_LIST.LAST
INSERT INTO A VALUES (LV_NUM_LIST(I));
END;
/

--OUTBIND--RESULT OF AN DML STMT INTO A COLLECTION WITH A MINIMAL CONTEXT SWITCHING 
--USING RETURNING

DECLARE
TYPE T_NUM_LIST_TYPE IS TABLE OF NUMBER;
LV_NUM_LIST T_NUM_LIST_TYPE;
BEGIN
UPDATE A SET COL=COL+100
RETURNING COL
BULK COLLECT INTO LV_NUM_LIST;
END;


---DEFINE
--HOLD OP OF A SELECT STMT INTO PLSQL COLLECTION USING BULK COLLECT
---

------------
--BULK COLLECT CLAUSE CAN USE IN 
--SELECT,FETCH,
--RETURNINIG INTO 


