CREATE OR REPLACE FUNCTION FN_SQUARE_CUBE (P_IN NUMBER)
RETURN SYS_REFCURSOR
AS
LV_REF_CUR SYS_REFCURSOR;
BEGIN
OPEN LV_REF_CUR FOR 
SELECT P_IN*P_IN AS COL FROM DUAL
UNION SELECT P_IN*P_IN*P_IN  FROM DUAL;
RETURN LV_REF_CUR;
END;
/
----CALLING METHOD;

SELECT FN_SQUARE_CUBE(2) FROM DUAL;
--{<COL=4>,<COL=8>,};
--BIND VARIABLE

VARIABLE X REFCURSOR;
EXEC :X:=FN_SQUARE_CUBE(2);
PRINT :X; 


------
DECLARE
LV_REF SYS_REFCURSOR;
LV_NAME NUMBER;
BEGIN
LV_REF:=FN_SQUARE_CUBE(2);
LOOP
FETCH LV_REF INTO LV_NAME
EXIT WHEN LV_REF%NOTFOUND;
END LOOP;
END;

--------PRAGMA AUTONOMOUS_TRANSACTION;
SAVEPOINT A;
INSERT INTO T VALUES(1);
SAVEPOINT B;

INSERT INTO T VALUES(2);

SAVEPOINT C;

INSERT INTO T VALUES(3);



ROLLBACK TO SAVEPOINT B;---AFTER SAVEPOINT B,ALL THE TRANSACTION WILL BE REVOKED

--------TO COMMIT INSIDE A TRIGGER

CREATE OR REPLACE TRIGGER BFR_TRIGER 
BEFORE INSERT ON T
FOR EACH ROW
BEGIN
COMMIT;
END;
/

----TO CALL A DML DUNCTION FROM A SELECT

CREATE OR REPLACE FUNCTION TEST 
RETURN NUMBER
AS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
INSERT INTO T VALUES(1);
RETURN 1;
END;
/

SELECT TEST FROM DUAL;


-----------
--CREATE TABLE ERROR_LOG
--(ERROR_NO NUMBER,ERROR_MSG VARCHAR2(100))
--/
DECLARE
LV_ERROR_NO NUMBER;
LV_ERROR_MSG VARCHAR2(100);

BEGIN
DELETE FROM T;
COMMIT;
INSERT INTO T VALUES('100');
INSERT INTO T VALUES(2);
INSERT INTO T VALUES('100');
INSERT INO T VALUES('200$');
COMMIT;
EXCEPTION WHEN OTHERS THEN
LV_ERROR_NO:=SQLCODE;
LV_ERROR_MSG:=SQLERRM;
ERROR_LOG_PROC(LV_ERROR_NO,LV_ERROR_MSG);
--INSERT INTO ERROR_LOG VALUES(LV_ERROR_NO,LV_ERROR_MSG);
    ROLLBACK;
END;
/
CREATE PROCEDURE ERROR_LOG_PROC (P_LV_ERROR_NO NUMBER,P_LV_ERROR_MSG VARCHAR2)
AS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
INSERT INTO ERROR_LOG VALUES(P_LV_ERROR_NO,P_LV_ERROR_MSG);
COMMIT;
END;
/

DROP PROCEDURE ERROR_LOG_PROC ;

SELECT * FROM ERROR_LOG;



---------------------CURSOR/EXCEPTION/COLLECTIONS/VIEW/SQL-PLSQL INTERACTION
--CURSOR

DECLARE
TYPE LV_EMP_LIST IS TABLE OF VARCHAR2(100);
TYPE_LV_EMP_LIST LV_EMP_LIST:=LV_EMP_LIST();
BEGIN
SELECT ENAME
BULK COLLECT INTO TYPE_LV_EMP_LIST
FROM EMP;
FOR I IN TYPE_LV_EMP_LIST.FIRST..TYPE_LV_EMP_LIST.LAST
LOOP
PRINT(TYPE_LV_EMP_LIST(I));
END LOOP;
END;

/
--POINTER TO THE MEMORY LOCATION WHERE INFO.ABOUT THE SELECT OR DML STATEMENT GETS STORED
DECLARE

CURSOR EMP_LIST IS
SELECT EANME FROM EMP;
LV_NAME EMP_LIST%TYPE;

BEGIN
OPEN EMP_LIST;
LOOP
FETCH EMP_LIST INTO LV_NAME;
PRINT(LV_NAME.ENAME);
EXIT WHEN EMP_LIST%NOT FOUND;
END LOOP;

CLOSE EMP_LIST;

----------
FOR I IN EMP_LIST
LOOP
END LOOP;


END;

---ANY STMT IS VIA CURSOR ONLY.AUTO-OPENS THE MEMORY LOCATION 	

--IMPLICIT CURSOR
--OWNERD BY PLSQL ..WE CANT HAVE ANY CONTROL--WE CAN JUST GET INFO FROM ITS ATTRIBUTES
--EXPLICIT 

----V$PARAMETERS
--V$OPEN CUROSR

-CUROSR ATTRIBUTES

------CURSOR_NAME%ISOPEN,CURSOR_NAME%FOUND,CURSOR_NAME%NOTFOUND,CURSOR_NAME%ROWCOUNT

DECLARE

CURSOR EMP_LIST IS
SELECT EANME FROM EMP;
LV_NAME EMP_LIST%TYPE;

BEGIN
IF EMP_LIST%ISOPEN
THEN
PRINT('CURSOR IS OPERNED');
ELSE
PRINT('CURSOR IS CLOSED');
PRINT
END IF;
OPEN EMP_LIST;

IF NOT EMP_LIST%ISOPEN 
THEN 
OPEN EMP_LIST;
END IF;


LOOP
FETCH EMP_LIST INTO LV_NAME;
PRINT(LV_NAME.ENAME||EMP_LIST%ROWCOUNT);
EXIT WHEN EMP_LIST%NOT FOUND;
END LOOP;

CLOSE EMP_LIST;

END;

-----------paramaeterized CURSOR

DECLARE
CURSOR EMP_NAME(P_DEPTNO NUMBER) IS SELECT ENAME FROM EMP WHERE DEPT_NO=P_DEPTNO;

BEGIN

OPEN EMP_NAME(10);
LOOP
FETCH EMP_NAME INTO LV;
EXIT;
END LOOP;
CLOSE EMP_NAME;

--------
FOR I IN EMP_NAME(20);
LOOP
PRINT(I.ENAME)
END LOOP;

END;


--------------REF CUROSR

--ALLOW US TO OPEN DIFFERNT QUERY


DECLARE
TYPE REF_CUR_TYPE IS REF CURSOR RETURN EMP%ROWTYPE;
RC_EMP_LIST REF_CUR_TYPE;
BEGIN
OPEN RC_EMP_LIST 
FOR SELECT ENAME FROM EMP;
LOOP

END LOOP;
CLOSE RC_EMP_LIST;

OPEN RC_EMP_LIST
FOR SELECT DEPTNO FROM DEPT;

END;
/

DECLARE

RC_EMP_LIST SYS_REFCURSOR;

BEGIN
OPEN RC_EMP_LIST FOR SELECT * FROM EMP;
FOR I IN RC_EMP_LIST
LOOP
PRINT(I.ENAME);

END LOOP;
END;


-----------TO RETURN OUT OF FUNCTION
CREATE FUNCTION EMP_LIST 
RETURN SYS_REFCURSOR
AS 
LV_EMP_LIST SYS_REFCURSOR;
BEGIN
OPEN LV_EMP_LIST
FOR SELECT ENAME FROM EMP;
RETURN LV_EMP_LIST;

END;
/

DECLARE
LV_REF_CUR  SYS_REFCURSOR;
LV VARCHAR2();
BEGIN
LV_REF_CUR:=EMP_LIST;
LOOP
FETCH LV_REF_CUR INTO LV;

END LOOP;
CLOSE LV_REF_CUR;
END;
/


------CAN BE USED TO RETURN TO CLIENT APPLICATION APT
-------CAN BE OPNED FOR DIFF.SQL STMTS..DYNAMIC SQL'S AND PASSED AS A PARAMETER BETWEEN PLSQL COMPONENTS




---------------PLSQL /SQL

PLSQL ENIGUNE

SQL ENGINE--BACK TO PLSQL IN SELECT 

ASSIGNIG A VALUE FROM PLSQL TO SQL AND VICE VERSA..IS CALLED BINDING

SWITCH BETWEEN AN ENGINE IS CONTEXT SWITCHING.


BEGIN
FOR I IN 1..100 
LOOP
								100 TIMES CONTEXT SWTICHIGN
END LOOP;
END;
/
--BULK BINDING

INBIND--SQL ->PLSQL
OUTBIND--PLSQL-->SQL IN DML

----------BULK COLLECT 

DECLARE
TYPE TT_NES_TAB_TYPE IS TABLE OF EMP%ROWTYPE;
LV_NEST_TAB TT_NES_TAB_TYPE;

BEGIN

SELECT * 
BULK COLLECT INTO LV_NEST_TABL
FROM EMP;

END;
/

DECLARE

TYPE T_NUM_lIST IS TABLE OF NUMBER;
LV_T_NUM_LIST T_NUM_lIST:=T_NUM_lIST(1,2,3,4,5);
BEGIN
FORALL I IN LV_T_NUM_LIST.FIRST..LV_T_NUM_LIST.LAST
INSERT INTO VALUES (LV_T_NUM_LIST(I));
END;
/


---------------SYS.ODCIVARCHAR2LIST

DECLARE
TYPE T_ENAME IS TABLE OF VARCHAR2(100);
LV_T_ENAME1 T_ENAME;
LV_T_ENAME2 T_ENAME;

BEGIN
FOR I IN (SELECT ENAME FROM EMP)
LOOP
LV_T_ENAME1.EXTEND();
LV_T_ENAME1(LV_T_ENAME1.LAST):=I.ENAME;
END LOOP;


SELECT ENAME
BULK COLLECT INTO LV_T_ENAME2
FROM EMP;

END;
/

DECLARE

TYPE T_TAB_TYPE IS TABLE OF EMP%ROWTYPE;
LV_T_TAB_TYPE T_TAB_TYPE;
BEGIN


SELECT *
BULK COLLECT INTO  LV_T_TAB_TYPE
FROM EMP;
FORALL I IN LV_T_TAB_TYPE.FIRS.FIRST..LV_T_TAB_TYPE.LAST
INSERT IMTO EMP2 VALUES(LV_T_TAB_TYPE(I	));

END;
/

---------EXCEPTION

CREATE FUNCTION FN_DEPT_TOT_SAL(P_DEPT_NO NUMBER)
RETURN NUMBER
AS
LV_TOTAL NUMBER;
BEGIN
SELECT SUM(SAL) INTO LV_TOTAL
FROM EMP WHERE DEPTNO=P_DEPT_NO;
RETURN LV_TOTAL;
EXCEPTION WHEN OTHERS THEN
	RETURN -1;
END;
/

-------NAMED
NO_DATA_FOUND
CUROSR_ALREADY_OPEN
TOO_MANY_ROWS
SUBSCRIPT_BEYOND_COUNT
SUB_OUTSIDE_LIMIT
DUP_VAL_ON_INDEX
ZERO_DIVIDE

-------UNNAMED

INSERT INTO EMP VALUES (9999999999999);


--USER
DECLARE
E EXCEPTION;

BEGIN
IF V2=0 THEN
	RAISE E;
END IF;
RESULT:=V1/V2;

END;
/
-------TO GIVE A NAME TO AN UNNAMED EXCEPTION

PRAGMA EXCEPTION_INIT (VARiABLE_OF_TYPE EXCEPTION,-01438);

---RAISE_APPLICATION_ERROR

DECLARE

DENOM_EQUAL_TO_ZERO EXCEPTION;


BEGIN
IF V2=0 THEN
	RAISE DENOM_EQUAL_TO_ZERO;
ELSE 
	RESULT:=V1/V2;
END IF;
EXCEPTION WHEN DENOM_EQUAL_TO_ZERO THEN



IF V2=0 THEN
RAISE_APPLICATION_ERROR(-200001,'DENOM EQUAL TO 0');-20001--->-20999
ELSE 
	RESULT:=V1/V2;
END IF;

END;
/


-------------SQLCODE/SQLERRM


--------VIEW/MV--NAMED QUERY----

--VIEW--ONLY VIEW  INFO STORED IN META TABLE
---MV-CREATE PHYSICAL MERMORY LOCATION OF RESULT--DATAT 

EXEC DBMS_MVIEW.REFRESH('MV_NAME');


USER_DEPENDENCIES
USER_OBJECTS

ALTER VIEW VW_NAME COMPILE;


--ADDING A NEW COL.WONT ADD INTO VIEW
--DROPPING A COLUMN ,WILL ERROR

---FORCE VIEW--INVALID ..WILL BECOME VALID ONCE THE TABLE IS CREATE 

WITH READ ONLY ---DML WONT 
WITH CHECK OPTION--WHILE INSERTING INTO VW ..CAN ONLY INSERT DATA OF WHAT METIONED IN THE WHERE OF VW CREATION 

CREATE OR REPLACE VIEW STU_ECE AS


-----------DELETE/TRUNCATE
--TRIGGER GETS FIRED FOR DELETE
	--
--ON DELETE CASCADE (DONT DELETE THE NULL FK'S),TRUNCATE CASCADE ()
CREATE TABLE CONT_TB
(CONT_ID NUMBER PRIMARY KEY,
CONT VARCHAR);

CREATE TABLE COUNTRY_TB
(C_ID NUMBER,
CONT_ID NUMBER,
CONSTANT COUNTRY_FK FOREIGN KEY (CONT_ID) REFERENCES CONT_TB(CONT_ID) ON DELETE CASCADE
);

-------



--
PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY ) OVER ();
